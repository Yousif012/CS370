#include "emit.h"
#include "ast.h"
#include <stdlib.h>

int STRING_COUNT = 0; // global variable for count of strings
int BRANCH_COUNT = 0; // global variable for count of branches (if and while statements)


void EMIT(ASTnode * p, FILE * fp){

    if(p == NULL) return;
    if(fp == NULL) return;
    
    fprintf(fp, "# MIPS code generated by Compilers class\n\n");
    fprintf(fp, ".data\n\n");
    EMIT_STRINGS(p, fp);
    fprintf(fp, ".align 2\n");
    EMIT_GLOBALS(p, fp);
    fprintf(fp, ".text\n\n\n");
    EMIT_AST(p, fp);

}


void EMIT_GLOBALS(ASTnode * p, FILE * fp){
    while (p){
        if (p->type == A_VARDEC && p->symbol->level == 0){
            fprintf(fp, "%s: .space %d\n", p->name, p->symbol->mysize*W_SIZE);
			ASTnode * varList = p->s1;
            while(varList){
                fprintf(fp, "%s: .space %d\n", varList->name, varList->symbol->mysize*W_SIZE);
                varList = varList->s1;
            }

        }
        p = p->next;
    }
}

void EMIT_STRINGS(ASTnode * p, FILE * fp){
    if(p == NULL) return;

    if (p->type == A_WRITE && p->name != NULL){
        p->label = CreateLabel();
        fprintf(fp, "%s: .asciiz %s\n", p->label, p->name);
    }

    EMIT_STRINGS(p->next, fp);
    EMIT_STRINGS(p->s1, fp);
    EMIT_STRINGS(p->s2, fp);
}

void EMIT_AST(ASTnode * p, FILE * fp){
    if(p == NULL)
        return;
    
    switch (p->type){

        case A_VARDEC:
            EMIT_AST(p->next, fp);
            break;
        
        case A_FUNCTIONDEC:
            emit_function(p, fp);
            EMIT_AST(p->next, fp);
            break;
        case A_COMPOUND:
            EMIT_AST(p->s1, fp);
            EMIT_AST(p->s2, fp);
            EMIT_AST(p->next, fp);
            break;
        case A_WRITE:
            emit_write(p, fp);
            EMIT_AST(p->next, fp);
            break;
        case A_READ:
            emit_read(p, fp);
            EMIT_AST(p->next, fp);
            break;
        case A_ASSIGN:
            emit_assign(p, fp);
            EMIT_AST(p->next, fp);
            break;
        case A_IF:
            emit_if(p, fp);
            EMIT_AST(p->next, fp);
            break;
        case A_WHILE:
            emit_while(p, fp);
            EMIT_AST(p->next, fp);
            break;
        case A_PARAM:
            emit_param(p, fp);
            EMIT_AST(p->next, fp);
            break;



        default:
            printf("EMIT_AST case %d not implemented\n", p->type);
            printf("WE SHOULD NEVER BE HERE\n");
            exit(1);
    }
}


char * CreateLabel()
{
    char hold[100];
    char *s;
    sprintf(hold,"_L%d",STRING_COUNT);
    s=strdup(hold);
    STRING_COUNT++;
    return (s);
}
char * CreateBranchLabel()
{
    char hold[100];
    char *s;
    sprintf(hold,"_B%d",BRANCH_COUNT);
    s=strdup(hold);
    BRANCH_COUNT++;
    return (s);
}


void emit_function(ASTnode * p, FILE * fp){

    char s[100];

    emit(fp, p->name, "", "function definition");

    // Carve out the Stack for activation record
    emit(fp, "", "move $a1, $sp", "Activation Record carve out copy SP");
    sprintf(s,"subi $a1, $a1, %d",p->symbol->offset*W_SIZE); 
    emit(fp, "", s,"Activation Record carve out copy size of function"); 
    emit(fp, "", "sw $ra, ($a1)","Store Return address ");
    sprintf(s, "sw $sp %d($a1)",W_SIZE);
    emit(fp, "", s, "Store the old Stack pointer");
    emit(fp, "", "move $sp, $a1","Make SP the current activation record");
    fprintf(fp, "\n\n");

    // copy the parameters to the formal from registers $t0 et
    EMIT_AST(p->s1, fp);

    // generate compound statement
    EMIT_AST(p->s2, fp);

    // restore RA and SP before we return
    emit(fp, "", "lw $ra ($sp)", "restore old environment RA");
    sprintf(s, "lw $sp %d($sp)", W_SIZE);
    emit(fp, "", s, "Return from function store SP");
    fprintf(fp, "\n");


    // create an implicit return depending on if we are main or not
    if(strcmp(p->name, "main") == 0){
        // exit the system
        emit(fp, "", "li $v0, 10", "Exit from Main");
        emit(fp, "", "syscall", "EXIT everything");
    }
    else{
        // jump back to the caller
    }
}

void emit_write(ASTnode * p, FILE * fp){
    char s[100];
    if(p->name != NULL){
        // need to load the address of label into $a0
        // and call print string
        sprintf(s, "la $a0, %s", p->label);
        emit(fp, "", s, "The string address");
        emit(fp, "", "li $v0, 4", "About to print a string");
        emit(fp, "", "syscall", "call write string");
        fprintf(fp, "\n\n");
    }
    else{
        emit_expr(p->s1, fp);
        emit(fp, "", "li $v0, 1", "About to print a number");
        emit(fp, "", "syscall", "call write number");
        fprintf(fp, "\n\n");
    }
} // emit_write

void emit_read(ASTnode * p, FILE * fp){

    emit_var(p->s1, fp); // $a0 will be the location of the variable
    emit(fp, "", "li $v0, 5", "About to read a value");
    emit(fp, "", "syscall", "read in value $v0 now has the read value");
    emit(fp, "", "sw $v0 ($a0)", "store read in value to memory");
    fprintf(fp, "\n\n");

}

void emit_var(ASTnode * p, FILE * fp){
    char s[100];
    
    printf("%s: %d\n", p->name, p->symbol->offset);


    // handle internal offset if array

    if(p->symbol->level == 0) // global variable
    {

        if(p->s1 != NULL){
            emit_expr(p->s1, fp);
            emit(fp, "", "move $a1, $a0", "VAR copy index array in a1");
            sprintf(s, "sll $a1, $a1 %d", LOG_W_SIZE);
            emit(fp, "", s, "muliply the index by wordszie via SLL");
        }
        // get the direct address of global var
        sprintf(s, "la $a0, %s", p->name);
        emit(fp, "", s, "EMIT Var global variable");

    }
    else{

        
        if(p->s1 != NULL) { // p is an array     
            emit_expr(p->s1, fp);
            emit(fp, "", "move $a1, $a0", "VAR copy index array in a1");
            sprintf(s, "sll $a1, $a1 %d", LOG_W_SIZE);
            emit(fp, "", s, "muliply the index by wordszie via SLL");
            emit(fp, "", "move $a0, $sp", "VAR copy index array in a1");
            sprintf(s, "addi $a0, $a0, %d", p->symbol->offset*W_SIZE);
            emit(fp, "", s, "VAR local stack pointer plus offset");

        }
        // local variable, Stack pointer plus offset
        else { // p is not an array
            emit(fp, "", "move $a0, $sp", "VAR local make a copy of stackpointer");
            sprintf(s, "addi $a0, $a0, %d", p->symbol->offset*W_SIZE);
            emit(fp, "", s, "VAR local stack pointer plus offset");
        }
    }

    // add on array index if needed
    if(p->symbol->SubType == SYM_ARRAY){
        emit(fp, "", "add $a0, $a0, $a1", "VAR array add internal offset");
    }
}


void emit_expr(ASTnode * p, FILE * fp){
    char s[100];

    // base cases
    switch(p->type){
        case A_NUM:
            sprintf(s, "li $a0, %d", p->value);
            emit(fp, "", s, "expression is a constant");
            return;
            break;
        case A_VAR:
            emit_var(p, fp); // $a0 is the memory location
            emit(fp, "", "lw $a0, ($a0)", "Expression is a VAR");
            return;
            break;
        case A_EXPR: break; // handled after switch

        default: printf("emit_expr switch NEVER SHOULD BE HERE\n");
                 printf("FIX FIX FIX\n");
                 exit(1);
    }
    
        
    // handle mathematical/conditional expressions
    // result will be in $a0
    if (p->type == A_EXPR){
        switch(p->operator){
            case A_PLUS:
                emit_expr(p->s1, fp);
                sprintf(s, "sw $a0, %d($sp)", p->symbol->offset*W_SIZE);
                emit(fp, "", s, "expression store LHS temporarily");
                emit_expr(p->s2, fp);
                emit(fp, "", "move $a1, $a0", "right hand side needs to be a1");
                sprintf(s, "lw $a0, %d($sp)", p->symbol->offset*W_SIZE);
                emit(fp, "", s, "expression restore LHS from memory");
                emit(fp, "", "add $a0, $a0, $a1", "EXPR ADD");
                break;
            case A_MINUS:
                emit_expr(p->s1, fp);
                sprintf(s, "sw $a0, %d($sp)", p->symbol->offset*W_SIZE);
                emit(fp, "", s, "expression store LHS temporarily");
                emit_expr(p->s2, fp);
                emit(fp, "", "move $a1, $a0", "right hand side needs to be a1");
                sprintf(s, "lw $a0, %d($sp)", p->symbol->offset*W_SIZE);
                emit(fp, "", s, "expression restore LHS from memory");
                emit(fp, "", "sub $a0, $a2, $a0", "EXPR SUB");
                break;
            case A_MULT:
                emit_expr(p->s1, fp);
                sprintf(s, "sw $a0, %d($sp)", p->symbol->offset*W_SIZE);
                emit(fp, "", s, "expression store LHS temporarily");
                emit_expr(p->s2, fp);
                emit(fp, "", "move $a1, $a0", "right hand side needs to be a1");
                sprintf(s, "lw $a0, %d($sp)", p->symbol->offset*W_SIZE);
                emit(fp, "", s, "expression restore LHS from memory");
                emit(fp, "", "mult $a1, $a0", "EXPR MULT");
                emit(fp, "", "mflo $a0", "Store multiplication result in $a0");
                break;
            case A_DIV:
                emit_expr(p->s1, fp);
                sprintf(s, "sw $a0, %d($sp)", p->symbol->offset*W_SIZE);
                emit(fp, "", s, "expression store LHS temporarily");
                emit_expr(p->s2, fp);
                emit(fp, "", "move $a1, $a0", "right hand side needs to be a1");
                sprintf(s, "lw $a0, %d($sp)", p->symbol->offset*W_SIZE);
                emit(fp, "", s, "expression restore LHS from memory");
                emit(fp, "", "div $a0, $a2", "EXPR DIV");
                emit(fp, "", "mfhi $a0", "Store divison result in $a0");
                break;
            case A_UMINUS:
                emit_expr(p->s1, fp); // get first arg
                emit(fp, "", "li $a2, 0", "Load 0 into $a2");
                emit(fp, "", "sub $a0, $a2, $a0", "EXPR UMINUS");
                break;
            case A_EE:
                // $a0 == $a2
                emit_expr(p->s1, fp);
                sprintf(s, "sw $a0, %d($sp)", p->symbol->offset*W_SIZE);
                emit(fp, "", s, "expression store LHS temporarily");
                emit_expr(p->s2, fp);
                emit(fp, "", "move $a1, $a0", "right hand side needs to be a1");
                sprintf(s, "lw $a0, %d($sp)", p->symbol->offset*W_SIZE);
                emit(fp, "", s, "expression restore LHS from memory");
                emit(fp, "", "seq $a0, $a0, $a1", "Compare $a0 and $a2 and store result in $a0");
                break;
            case A_NE:
                // $a0 != $a2
                emit_expr(p->s1, fp);
                sprintf(s, "sw $a0, %d($sp)", p->symbol->offset*W_SIZE);
                emit(fp, "", s, "expression store LHS temporarily");
                emit_expr(p->s2, fp);
                emit(fp, "", "move $a1, $a0", "right hand side needs to be a1");
                sprintf(s, "lw $a0, %d($sp)", p->symbol->offset*W_SIZE);
                emit(fp, "", s, "expression restore LHS from memory");
                emit(fp, "", "sne $a0, $a0, $a1", "Compare $a0 and $a2 and store result in $a0");
                break;
            case A_LT:
                // $a2 < $a0
                emit_expr(p->s1, fp);
                sprintf(s, "sw $a0, %d($sp)", p->symbol->offset*W_SIZE);
                emit(fp, "", s, "expression store LHS temporarily");
                emit_expr(p->s2, fp);
                emit(fp, "", "move $a1, $a0", "right hand side needs to be a1");
                sprintf(s, "lw $a0, %d($sp)", p->symbol->offset*W_SIZE);
                emit(fp, "", s, "expression restore LHS from memory");
                emit(fp, "", "slt $a0, $a0, $a1", "Compare $a0 and $a2 and store result in $a0");
                break;
            case A_LET:
                // $a2 <= $a0
                emit_expr(p->s1, fp);
                sprintf(s, "sw $a0, %d($sp)", p->symbol->offset*W_SIZE);
                emit(fp, "", s, "expression store LHS temporarily");
                emit_expr(p->s2, fp);
                emit(fp, "", "move $a1, $a0", "right hand side needs to be a1");
                sprintf(s, "lw $a0, %d($sp)", p->symbol->offset*W_SIZE);
                emit(fp, "", s, "expression restore LHS from memory");
                emit(fp, "", "sle $a0, $a0, $a1", "Compare $a0 and $a2 and store result in $a0");
                break;
            case A_BT:
                // $a2 > $a0
                emit_expr(p->s1, fp);
                sprintf(s, "sw $a0, %d($sp)", p->symbol->offset*W_SIZE);
                emit(fp, "", s, "expression store LHS temporarily");
                emit_expr(p->s2, fp);
                emit(fp, "", "move $a1, $a0", "right hand side needs to be a1");
                sprintf(s, "lw $a0, %d($sp)", p->symbol->offset*W_SIZE);
                emit(fp, "", s, "expression restore LHS from memory");
                emit(fp, "", "sgt $a0, $a0, $a1", "Compare $a0 and $a2 and store result in $a0");
                break;
            case A_BET:
                // $a2 >= $a0
                emit_expr(p->s1, fp);
                sprintf(s, "sw $a0, %d($sp)", p->symbol->offset*W_SIZE);
                emit(fp, "", s, "expression store LHS temporarily");
                emit_expr(p->s2, fp);
                emit(fp, "", "move $a1, $a0", "right hand side needs to be a1");
                sprintf(s, "lw $a0, %d($sp)", p->symbol->offset*W_SIZE);
                emit(fp, "", s, "expression restore LHS from memory");
                emit(fp, "", "sge $a0, $a0, $a1", "Compare $a0 and $a2 and store result in $a0");
                break;
            default: printf("Operator %d is not implemented", p->operator);
                     exit(1);
            }

    }
}

void emit_assign(ASTnode * p, FILE * fp){
    char s[100];

    emit_expr(p->s2, fp);
    sprintf(s, "sw $a0, %d($sp)", p->symbol->offset*W_SIZE);
    emit(fp, "", s, "Assign store RHS temporarily");
    emit_var(p->s1, fp);
    sprintf(s, "lw $a1, %d($sp)", p->symbol->offset*W_SIZE);
    emit(fp, "", s, "Assign get RHS temporarily");
    emit(fp, "", "sw $a1, ($a0)", "Assign new value to variable");
    fprintf(fp, "\n\n");
}

void emit_if(ASTnode * p, FILE * fp){
    char s[100];
    
    p->label = CreateBranchLabel();
    p->s2->label = p->label;

    emit_expr(p->s1, fp);

    emit(fp, "", "li $a1, 1", "Load 1 into $a1");
    sprintf(s, "beq $a0, $a1, %s", p->label);
    emit(fp, "", s, "Start conditional statement");

    emit_ifBody(p->s2, fp);

    fprintf(fp, "\n\n");
}

void emit_ifBody(ASTnode * p, FILE * fp){
    char s[100];

    fprintf(fp, "\n\n\t# Enter else statement body\n");
    EMIT_AST(p->s2, fp);
    sprintf(s, "b %s%s", p->label, "_exit");
    emit(fp, "", s, "Exit if statement");
    fprintf(fp, "\n\n\t# Enter if statement body\n");
    sprintf(s, "%s:", p->label);
    emit(fp, "", s, "");
    EMIT_AST(p->s1, fp);
    sprintf(s, "%s%s:", p->label, "_exit");
    emit(fp, "", s, "Continue program");
}

void emit_while(ASTnode * p, FILE * fp){
    char s[100];
    
    p->label = CreateBranchLabel();
    p->s2->label = p->label;

    fprintf(fp, "\n\n\t# Enter while statement condition\n");

    sprintf(s, "%s:", p->label);
    emit(fp, "", s, "");

    emit_expr(p->s1, fp);

    sprintf(s, "beq $a0, $0, %s%s", p->label, "_exit");
    emit(fp, "", s, "");

    fprintf(fp, "\n\n\t# Enter while statement body\n");

    EMIT_AST(p->s2, fp);

    sprintf(s, "b %s", p->label);
    emit(fp, "", s, "continue while statement");

    sprintf(s, "%s%s:", p->label, "_exit");
    emit(fp, "", s, "Continue program");

    fprintf(fp, "\n\n");
}

void emit_param(ASTnode * p, FILE * fp){
    char s[100];

    return;

}

void emit(FILE *fp, char * label, char * command, char * comment)
{
    if (strcmp("", comment) == 0 ) 
        if (strcmp("",label) == 0)
            fprintf (fp,"\t%s\t\t\n", command );
        else
            fprintf(fp,"%s:\t%s\t\t\n",label, command);
    else
        if (strcmp("",label) == 0)
            fprintf(fp,"\t%s\t\t# %s\n", command, comment);
        else
            fprintf(fp,"%s:\t%s\t\t# %s\n",label, command, comment);
}